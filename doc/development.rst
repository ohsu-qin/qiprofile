===============
Developer Guide
===============

********
Overview
********

The ``qiprofile`` module implements the Imaging Profile UI web
application.


************
Dependencies
************
The server library dependencies are manged by npm_ using the ``package.json``
dependencies list. The run-time client library dependencies are managed by
jspm_ in the ``package.json`` entry. The library lists specify the last known
working version configuration.

The npm or jpsm ``update`` command fetches the most current
compatible version, e.g. an update of the specification::

    "chai": "^1.8.1"

will install the most recent 1.x version, but not a 2.x version.

See the *Development* section below for adding a new dependency.


*****
Setup
*****

1. Follow the `qiprofile installation instructions`_, omitting the
   ``--production`` option.

2. Install the Grunt_ CLI command globally::

       npm install -g grunt-cli

3. Run the following in a console from the ``qiprofile`` directory::

       npm install

   This command installs the necessary packages [#xtk_fork]_.

4. Run the following Grunt_ script::

       grunt

   The default Grunt task builds the project. The following command
   lists the available Grunt tasks::

       grunt --help


***
API
***

The ``grunt`` default build task builds the API documentation at
``build/doc/api/index.html`` in the project workspace.


******
Update
******

Update the ``qiprofile`` workspace as follows::

    git pull
    npm install
    npm prune

Check periodically for outdated package specifications by running npmedge_.


***********
Development
***********

Project structure
-----------------
The project is organized as follows::

    qiprofile/        # Top-level project directory
      src/            # Source code
        <module>/     # <module> source corresponding to a navigable view
          <module>.pug # View HTML source
          help.md     # Help content
          include/    # pug include files
        layout/       # Common HTML layout
      public/         # The generated web app files
        html/         # HTML generated by pug files
        stylesheets/  # Stylus style sheets
        fonts/        # Copied fonts
        static/       # Copied static content
      bin/            # Command line scripts
        qiprofile     # Web app server script
      doc/            # Application documentation
      build/          # Target build
        src/          # Build staging area
        doc/          # Generated documentation
          html/       # Generated guides
          api/        # Generated JSDoc
      server.js       # Express server startup script
      static/         # Source static content
        media/        # Images, icons and videos
      testing/           # Top-level test directory
        conf/         # Test configuration files
        e2e/          # End-to-end tests
        unit/         # Unit tests
        fixtures/     # Static test fixtures, e.g. input files

Adding dependencies
-------------------
Add a new client library as follows::

    jspm install <library>

Add a new server library as follows::

    npm install --save <library>

Add a new build or test library as follows::

    npm install --save-dev <library>

In both cases, after adding the dependency, edit the modified
``package.json`` dependency list to move the added dependency
entry to the appropriate position in the list. The list is in
alphabetical sort order.

Testing
-------
Testing is performed by the following grunt tasks\ [#midway]_:

* ``test:unit``: Run the unit tests

* ``test:e2e``: Run the end-to-end tests

The unit tests are run with the Karma_ test runner using the Mocha_ and
Chai_ frameworks and the PhantomJS_ headless server. The command::

    grunt test:unit

runs the grunt karma ``unit`` task as follows:

* Read the ``testing/conf/karma-conf.coffee`` configuration file

* Start a headless web server as the Mocha test context

* Exercise the ``src/**/*.spec.*`` test cases

* Print the result to the console

Restrict the tests to run by appending ``.only`` to the target ``describe``
block test suite.

-----

Debugging a unit test case is performed as follows:

* Run the grunt task with the ``--debug`` option, e.g.::

      grunt --debug test:unit

  This starts a Chrome_ test runner but does not run the tests.

* Press the ``DEBUG`` button on the launch page.

* Open the Chrome Developer Tools (DevTools_).

* Set a breakpoint in the ``base/public/app.js`` source file.

* Refresh the page.

-----

The end-to-end tests are run with the Protractor_ framework. The command::

    grunt test:e2e

runs the grunt protractor ``e2e`` task. The Express server must be
running when ``e2e`` is started.

The ``e2e`` task executes as follows:

* Read the ``testing/conf/protractor-conf.coffee`` configuration file

* Start the Express test server on port 3001

* Start a Selenium web server as the Mocha test context

* Run the qirest_ test seed program

* Exercise the ``src/**/*.e2e-spec.*`` test cases

* Print the result to the console

Note that the e2e task can fail because of Selenium startup timing issues.
If the test results in a failed connection error, the rerun the task.

A single end-to-end test spec can be run with the ``--specs`` option::

      grunt --specs <spec> test:e2e

The best way to create an end-to-end test is to copy an existing test.
``src/projects/projects.e2e-test.coffee`` is a good example. The ``Page``
helper encapsulates the page being tested.

End-to-end testing notes:

* Running the tests can result in the following errors::

      Client error: SyntaxError: Unexpected end of input

      Client error: Error: [$compile:tpload] Failed to load template: /partials/intensity-chart.html

  The partial does load in the browser and it appears that the
  tests are not affected. These messages began occuring after updating
  test packages, but they cannot be isolated to a particular package.
  Since the messages seem to be benign, it is ignored for now.

  TODO - revisit this after applying npmedge in late 2015.

* A Page can be instantiated in a before (once per suite) or a beforeEach
  (once per test case).

  Sometimes the beforeEach page results in an error,
  e.g. if volumeSpec were changed from before to beforeEach then the
  volume resource fails to load. In those cases, use a before page.

  Sometimes, the before page results in an error, e.g. if subjectListSpec
  were changed from beforeEach to before then the following error is
  raised:

      Error while waiting for Protractor to sync with the page

  In those cases, use a beforeEach page. The putative rationale for the
  difference is the interaction of Protractor with Selenium on angular vs.
  non-angular pages
  (cf. http://stackoverflow.com/questions/23634648/getting-error-error-while-waiting-for-protractor-to-sync-with-the-page/23881721#23881721).

  Briefly, the advice is to get the page as follows:

  * browser.get on angular pages with the Protractor API

  * browser.driver.get on non-angular pages with the Selenium API

  However, that rationale does not apply in the aforementioned examples.
  The best, albeit terrible, approach is trial-and-error and cross your
  fingers that it doesn't break over time.

  TODO - there must be a better answer!

* The ``it.only`` qualifier results in the following error::

      /Users/loneyf/workspace/qiprofile/node_modules/mocha/lib/interfaces/bdd.js:124
            var reString = '^' + utils.escapeRegexp(test.fullTitle()) + '$';
                                                         ^
      TypeError: Cannot call method 'fullTitle' of undefined
          at Function.context.it.only (/Users/loneyf/workspace/qiprofile/node_modules/mocha/lib/interfaces/bdd.js:124:52)
          ...

  ``describe.only`` runs correctly in protractor. Both ``it.only`` and ``describe.only``
  run correctly in karma unit tests.

  The work-around is to confine use of ``only`` to ``describe``.

  TODO - retry ``it.only`` in 2016.

* An inner before which depends on a DOM element defined in an outer beforeEach
  results in the following error::

      StaleElementReferenceError: stale element reference: element is not attached to the page document

  This error is caused by resetting the parent DOM element with each test case,
  but not refreshing the child DOM element. The resolution is to ensure that
  the inner and outer contexts are either both beforeEach or both before clauses.

Coding Standards
----------------
* All unit and end-to-end tests must run successfully before any
  ``git push`` to the GitHub master branch.

* Every new feature should be verified by a new test suite.

* Every bug fix should be verified by a new test case that fails
  before the bug fix and succeeds after the bug fix.

* All modules are TypeScript. Services are either Typescript or
  CoffeeScript. If working from a JavaScript example, adapt it to an
  equivalent CoffeeScript, which has the added benefit of understanding
  and trimming the example.

* CoffeeScript import and export statements are escaped in order to pass
  them on to JavaScript, e.g.::

      `import REST from "./rest.coffee"`
      `export { REST as default }`

  The export ``as default`` ensures ES6 and TypeScript interoperability.
  Libraries with an ``index.js`` in the package root folder, e.g. ``lodash``,
  need to be imported using ``* as``, e.g.::

      `import * as _ from "lodash"`

* The CoffeeScript service modules export a singleton variable, e.g.::

      Rest =
        ...
      `export { Rest as default }`

* Every TypeScript class and CoffeeScript export is documented with
  YUIDoc_ comments. Every public function is documented. Every private
  function that is not self-explanatory is documented and marked with
  the ``@private`` tag.

* CoffeeScript comments must compile to ``/** ... */`` blocks  in
  JavaScript, e.g.::

      ###*
       * Formats the {where: condition} Eve REST query parameter.
       *
       * @method where
       * @param params the input parameters
       * @return the REST condition query parameter
      ###
      where: (params) ->

  Note that the block is in the form::

      ###*
       * Good
      ###

  rather than::

      ###
      #  Bad!
      ###

* Each CoffeeScript service module include a static class comment block,
  e.g.::

      ###*
       * @class Rest
       * @static
      ###

* Every TypeScript class is tested in a TypeScript test case. Every
  CoffeeScript module is tested in a CoffeeScript test case. The test
  cases are compiled on the fly to JavaScript by a Karma_ or Protractor_
  pre-processor.

* Every application Angular component file is indicated by ``.component.``
  in the file name, e.g. ``app.component.ts``.

* Every application Angular service file is indicated by ``.service.``
  in the file name, e.g. ``collections.service.ts``.

* Every application Angular data file is indicated by a simple file name
  without a qualifier, e.g. ``collection.ts``.

* Every component template file is indicated by a simple file name
  without a qualifier, e.g. ``collection.pug``.

* Every application Angular selector is prefixed by ``qi-``, e.g.
  ``qi-spin`` to refer to the ``Spin`` component.

* All application CSS is compiled from the ``stylus/site.styl`` Stylus
  file.

* Non-test file names are lower case hyphenated rather than underscore.

* Test case file names are camelCase beginning with the application
  module or partial being tested and ending in ``Spec``, e.g.
  ``testing/e2e/subjectListSpec.coffee``.

* CoffeeScript follows the `CoffeeScript Style Guide`_.

* CoffeeScript variable names are camelCase rather than underscore.

* CoffeeScript imports another module with an escaped ``import``
  statement, e.g.::

      `import * as _ from "lodash"`

  Note that the imported module name uses double quotes rather than
  single quotes for readability.

* Each application CoffeeScript file makes an object that is exported
  with an escaped ``export`` statement, e.g.::

      REST =
        ... # the service definition

      `export { REST as default }`

  The service can then be imported by a TypeScript file with import,
  e.g.::

      import REST from '../rest/rest.ts';

  CoffeeScript unit test suites do not need to be exported.

* Each intra-``src/`` import is relative, e.g.::

      import REST from './rest.coffee';  // good

  rather than::

      import REST from 'src/rest/rest.coffee'; // bad!

* Outside imports of source files, e.g. from a test suite, are rooted at
  ``app/``, e.g.::

      import REST from 'app/rest.coffee';  // good from testing/

  rather than::

      import REST from '../../src/rest/rest.coffee'; // bad from testing/!
      import REST from 'src/rest/rest.coffee'; // bad from testing/!

  ``app/`` is a ``src/`` alias defined in the jspm ``paths`` option.

* Source code lines are no longer than 80 characters, unless a single
  line is more readable.

* Comment lines are no longer than 72 characters, unless a single line
  is more readable.

* Function calls are on one line unless they exceed the recommended
  length, e.g.::

      a = _.concat(first, second)  # Good

  rather than::

      a = _.concat(first,  # Bad
                   second)

* Function arguments are aligned when the function call extends to more
  than one line, e.g.::

      a = _.concat(first, second, third, fourth, fifth, sixth, seventh,
                   eighth)

* Arguments for a function with a long name are placed on a separate
  line if it is more readable, e.g.::

      aLongVariableName.anEvenLongerFunctionName(
          anotherLongVariableName, yetAnotherLongerVariableName
      )

  The closing parenthesis is placed on a separate line if and only if
  the arguments are on a separate line.

* A string argument that extends over one line is broken into a
  concatenation of aligned substrings, e.g.::

      console.log("A long string like this is broken into aligned" +
                  " substrings.")

* CoffeeScript function calls with an anonymous function argument
  omit parentheses if and only if the function is defined on a
  separate line, e.g.::

      result = _.sortBy(array, (a, b) -> a.priority - b.priority)
      result = _.sortBy array, (a, b) ->
          a.priority - b.priority

* Functions extending over several lines are defined in a separate
  variable rather than an anonymous argument, e.g.::

      sort_criterion = (a, b) ->
          .
          .
          .
      result = _.sortBy(array, sort_criterion)

* Function and array boundaries are not padded with a string, e.g.::

      module = angular.module('qiprofile')    # Good
      numbers = [1, 2, 3]

  rather than::

      module = angular.module( 'qiprofile' )  # Bad
      numbers = [ 1, 2, 3 ]

* CoffeeScript function definitions without arguments omit the
  parentheses, e.g.::

      doSomethingUseful = ->
        ...

* A throw argument is always an Error object rather than a string,
  e.g.::

      throw new Error(message)   # Good

 rather than::

      throw new message   # Bad

* Error messages are simple, informative text without ending punction,
  e.g.::

      throw new Error("The file type is not recognized: #{ file }") # Good

  rather than::

      throw new Error("Bad file type!")  # Bad

* CoffeeScript, pug and Stylus string literals have double quotation
  marks if they are evaluated or interpolated, single quotation marks
  otherwise, e.g.::

      simpleString = 'A string'
      interpolatedString = "#{ anotherVariable } string"
      evaluatedString = "data" # where data is evaluated, e.g. by the Angular compiler
      evaluatedConstant = "'none'" # which evaluates to the string 'none'

  Interpolations are padded with a space.

* TypeScript and CoffeeScript promise chain ``.then`` clauses are indented,
  e.g.::

      promise
        .then (result) ->
          ...
        .then (more) ->
          ...

* Single unchanined promise ``.then`` calls are on the same line, e.g.::

      promise.then (result) ->
        ...

* Every application selector is dash-separated lower case preceded by ``qi``,
  e.g. ``qi-subject``.

* Every custom CSS style is dash-separated lower case preceded by ``qi``,
  e.g. ``qi-billboard``.

* Comments are readable English on a separate line, usually beginning
  with a capitalized 'The' and ending in a period.

* Every public module, class and function is commented using the
  `Writing AngularJS Documentation`_ guideline.[#docCaveat]_

* Each function which is not nested within another function is documented
  using the jsdoc_ convention.

* Each application AngularJS module is documented using the ngdoc_
  convention.

* Pending code changes are described in a ``TODO`` comment.

* Release-critical bugs are described in a ``FIXME`` comment. These items
  should be fixed and the comment deleted before a new major version is
  tagged and released.

* Edit forms conform to the REST data model. Specifically:

  - Validate the data upon input as determined by the model
    validation.

  - Resolve conflicts between data capture and the model, e.g. the
    default value or validation.

* Changes are made in a git branch. Make a local git branch by executing
  the following command::

      git checkout -b <branch>

  The branch name is dash-delimited underscore, e.g. ``image-detail``.
  A long-lived or jointly developed branched is pushed to master, e.g.

      git push origin <branch>

  Rebase the branch from time to time as follows:

      git rebase master

  This integrates the branch with the master, detects conflicts and
  facilitates subsequent merge.

  Before merging the branch with the master, rebase and run all tests:

      grunt test

  The branch is merged into the master with the following commands:

      git checkout master
      git merge --no-ff <branch>

  Note the ``--no-ff`` option, which ensures that an audit trail of the
  merge is kept in a log commit, even if there are no merge conflicts.

* The first step in adding new functionality is to create a (failing)
  test case. Add new expectations to the test case as development
  progresses. A passing full-featured test case is necessary before
  integrating the branch into the master.

* Commit git changes early and often. The commit message is a concise,
  meaningful, readable change description. The message begins with a
  capital letter and ends with a period, e.g.::

      Add a bolus arrival bar to the intensity chart.

  rather than::

      change intensity chart

  If a git comment is longer than one sentence, then the commit probably
  should have been broken out into several commits.

* Version numbers follow the *major*\ .\ *minor*\ .\ *patch* SemVer_
  scheme, where:

  * *major* is 0 for pre-release development, 1 for the initial alpha
    public release, 2 for the beta public release, and incremented
    thereafter when a major feature set is introduced.

  * *minor* is 0 for unstable major version development checkpoints,
    1 for the initial public major version release, and incremented
    thereafter for each non-backward-compatible change.

  * *patch* is a number only starting at 1, and incremented with each
    backward-compatible change.

  A release is published to npm if and only if it is a public release,
  as described below.

* Prepare to publish changes as follows:

  - Check in all tested changes.

  - Rebase, test and merge the branch as described above.
    You should now be on the ``master`` branch.

* Contributors submit changes by pushing the changes to a GitHub
  fork and sending a pull request to the main qiprofile GitHub
  repository.

* Committers add a new version as follows:

  - Add a short version theme description to ``History.rst``.

  - Increment the ``package.json`` version attribute.

  - Set a git tag with a ``v`` prefix, e.g.::

        git tag v2.1.2

  - Update the server::

        git push
        git push --tags

  - Publish the new module to NPM if and only if the release is
    public, i.e. the version *major* and *minor* are 1 or above.
    Changes are published to NPM as follows (cf. the `NPM
    Publishing Guide`_)::

        npm publish

  - Periodically delete unused local and remote branches. Exercise care
    when deleting a stale remote branch. See the
    `Pro Git Book`_ `Deleting Remote Branches`_ section for details.


**********
Deployment
**********

The deployment targets requires two server machines:

* the XNAT server

* the server hosting the qiprofile Express_, qirest_ Eve
  and qirest_ MongoDB services

Both servers share a Direct Attached Storage (DAS) XNAT archive
directory, e.g. if the DAS mount point is ``/home/groups/quip``
then create the archive directory as follows::

    mkdir -p /home/groups/quip/xnat/archive

The XNAT server is configured to place the image files on this DAS
volume via a symbolic link, e.g.::

    ln -s /home/groups/quip/xnat/archive /var/local/xnat

Thus, when XNAT archives an image file it places it in the standard XNAT
location ``/var/local/xnat/archive``, which in turn resolves the shared
DAS volume location.

XNAT places the image files according to its own fixed hierarchy. For
example, given the above DAS configuration, then the sarcoma patient 1
visit 1 scan 50 file has the following location::

    /home/groups/quip/xnat/archive/
      QIN/arc001/Sarcoma001_Session01/SCANS/50/NIFTI/series050.nii.gz

The corresponding image file for the registration named ``reg_j3P9u``
would be::

    /home/groups/quip/xnat/archive/
      QIN/arc001/Sarcoma001_Session01/RESOURCES/reg_j3P9u/series050.nii.gz

on the shared DAS volume of both servers.

The Express server hosts the qiprofile web app at the following root
directory::

    /var/local/express/webapps/qiprofile

Express finds the image data in the ``data`` subdirectory. Create a
symbolic link to the shared XNAT image location, e.g.::

    ln -s /home/groups/quip/xnat/archive /var/local/express/webapps/qiprofile/data

The qirest data model ``Scan`` and ``Registration`` ``files``
field consists of the image file path for each volume. A qipipe_ pipeline task
populates the MongoDB ``qiprofile`` database with new MR session imaging fields,
filling in the files list with the file paths relative to the parent project
location, e.g.::

    Sarcoma001_Session01/SCANS/50/NIFTI/series050.nii.gz

The qiprofile router reads this data into a Javascript session object,
e.g.::

    scan: {
      files: [..., 'Sarcoma001_Session01/SCANS/50/NIFTI/series050.nii.gz', ...]
    }

When the Session Detail scan or registration image download button
is clicked, then qiprofile builds the file location relative to the web app
root directory, e.g.::

    data/QIN/arc001/Sarcoma001_Session01/SCANS/50/NIFTI/series050.nii.gz

where ``QIN`` is the project name. qiprofile then dispatches an HTTP XHR_
request for the static file at that location::

     HTTP GET /static/data/QIN/arc001/Sarcoma001_Session01/SCANS/50/NIFTI/series050.nii.gz

The qiprofile Express server recognizes the ``/static/`` prefix as a request for
a file relative to the web app root and returns the content of the server file,
in this case the file at::

      /var/local/express/webapps/qiprofile/
        data/QIN/arc001/Sarcoma001_Session01/SCANS/50/NIFTI/series050.nii.gz

When the file content is received by the qiprofile client, then the Session Detail
image download button is hidden and the open button is shown. When the open
button is clicked, then the Image Detail page is visited with the image file
content.

The ``qirest`` ``testing/seed.py`` script populates the
``ImageContainer`` ``files`` field described above for the 24 Breast and
Sarcoma test MR sessions. The ``grunt test:e2e`` end-to-end testing task runs
the ``qirest`` seed script and creates a link in the local ``public``
web app build to the test image file fixtures location::

      public/data -> ../testing/fixtures/data

The test image files conform to the XNAT file location convention, e.g.::

      testing/fixtures/data/
        QIN_Test/arc001/Sarcoma001_Session01/SCANS/50/NIFTI/series050.nii.gz

---------

.. container:: copyright

.. rubric:: Footnotes

.. [#xtk_fork]
  Note that XTK_ is not packaged for Bower_ or npm_. The `XTK Bower Fork`_
    remedies this omission. The qiprofile ``bower.json`` definition file
    specifies this GitHub fork. The ``edge`` XTK version is used, following
    the recommendation on the XTK_ home page.

.. [#midway]
   The ngMidwayTester_ purports to offer a testing solution intermediate
   to unit and end-to-end testing. However, this package was evalutated
   and found to be faulty and poorly documented, supported and maintained.

.. [#docCaveat]
   Unfortunately, there is not yet a known means of generating AngularJS
   Coffeescript API documentation. `Dgeni`_ ngdoc parsing does not have a
   Coffeescript adapter. `CoffeeDoc`_ `Codo`_ does not parse AngularJS modules.
   The  `Comment passthrough workaround`_ is no help, since ngdoc does not
   detect classes or functions in the compiled Javascript. The best solution
   is the `Dgeni CoffeeScript documentation extractor`_ enhancement proposal.

.. Targets:

.. _angular-app: https://github.com/angular-app/angular-app

.. _Bower: https://bower.io/

.. _Chai: http://chaijs.com/

.. _Chrome: https://www.google.com/intl/en_us/chrome/browser/

.. _Codo: https://github.com/coffeedoc/codo

.. _CoffeeScript Style Guide : https://github.com/polarmobile/coffeescript-style-guide

.. _CoffeeDoc: http://coffeedoc.info/

.. _`Comment passthrough workaround`: http://stackoverflow.com/questions/7833021/how-to-document-coffeescript-source-code-with-jsdoc/9157241#9157241

.. _Deleting Remote Branches: http://git-scm.com/book/en/Git-Branching-Remote-Branches#Deleting-Remote-Branches

.. _DevTools: https://developer.chrome.com/devtools/index

.. _Dgeni: https://github.com/angular/dgeni

.. _Dgeni CoffeeScript documentation extractor: https://github.com/angular/dgeni/issues/69

.. _Express: http://expressjs.com/

.. _Grunt: http://www.gruntjs.com/

.. _jsdoc: http://usejsdoc.org/

.. _jspm: http://jspm.io

.. _Karma: http://karma-runner.github.io/0.10/index.html

.. _Mocha: http://visionmedia.github.io/mocha/

.. _ngMidwayTester: https://github.com/yearofmoo/ngMidwayTester

.. _Node.js: https://www.nodejs.org/

.. _npm: https://www.npmjs.org/

.. _npmedge: https://www.npmjs.com/package/npmedge#overview

.. _NPM Publishing Guide: https://docs.npmjs.com/getting-started/publishing-npm-packages

.. _ngdoc: https://github.com/angular/angular.js/wiki/Writing-AngularJS-Documentation

.. _PhantomJS: http://phantomjs.org/

.. _Pro Git Book: http://git-scm.com/book/en/

.. _Protractor: https://github.com/angular/protractor

.. _qipipe: https://github.com/ohsu-qin/qipipe

.. _qiprofile installation instructions: https://github.com/ohsu-qin/qiprofile/blob/master/doc/index.rst

.. _qirest: https://github.com/ohsu-qin/qirest

.. _SemVer: http://semver.org/

.. _Writing AngularJS Documentation: https://github.com/angular/angular.js/wiki/Writing-AngularJS-Documentation

.. _XHR: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest

.. _XTK: http://www.goXTK.com

.. _XTK Bower Fork: https://www.github.com/FredLoney/get

.. _YUIDoc: http://yui.github.io/yuidoc/
